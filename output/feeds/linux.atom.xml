<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>nJcx's Blog - Linux</title><link href="http://www.njcx.bid/" rel="alternate"></link><link href="http://www.njcx.bid/feeds/linux.atom.xml" rel="self"></link><id>http://www.njcx.bid/</id><updated>2017-02-16T10:20:00+03:00</updated><entry><title>docker 常用命令记录</title><link href="http://www.njcx.bid/posts/B4.html" rel="alternate"></link><published>2017-02-16T10:20:00+03:00</published><updated>2017-02-16T10:20:00+03:00</updated><author><name>nJcx</name></author><id>tag:www.njcx.bid,2017-02-16:/posts/B4.html</id><summary type="html">&lt;p&gt;介绍一下docker常用命令，记录一下学习过程&lt;/p&gt;</summary><content type="html">&lt;h4&gt;查看docker信息（version、info）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;查看docker版本  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;docker version &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;显示docker系统的信息  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;docker info  &lt;/p&gt;
&lt;h4&gt;对image的操作（search、pull、images、rmi、history）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;检索image  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;docker search image_name  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;下载image &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;docker pull image_name  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;列出镜像列表; -a, --all=false Show all images; --no-trunc=false Don't truncate output; -q, --quiet=false Only show numeric IDs  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;docker images  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;删除一个或者多个镜像; -f, --force=false Force; --no-prune=false Do not delete untagged parents  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;docker rmi image_name  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;显示一个镜像的历史; --no-trunc=false Don't truncate output; -q, --quiet=false Only show numeric IDs  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;docker history image_name &lt;/p&gt;
&lt;h4&gt;启动容器（run）&lt;/h4&gt;
&lt;p&gt;Docker容器可以理解为在沙盒中运行的进程。这个沙盒包含了该进程运行所必须的资源，包括文件系统、系统类库、shell 环境等等。但这个沙盒默认是不会运行任何程序的。你需要在沙盒中运行一个进程来启动某一个容器。这个进程是该容器的唯一进程，所以当该进程结束的时候，容器也会完全的停止。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在容器中运行"echo"命令，输出"hello word"  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;docker run image_name echo "hello word"  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;交互式进入容器中 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;docker run -i -t image_name /bin/bash  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在容器中安装新的程序  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;docker run image_name apt-get install -y app_name  &lt;/p&gt;
&lt;p&gt;Note：  在执行apt-get 命令的时候，要带上-y参数。如果不指定-y参数的话，apt-get命令会进入交互模式，需要用户输入命令来进行确认，但在docker环境中是无法响应这种交互的。apt-get 命令执行完毕之后，容器就会停止，但对容器的改动不会丢失。&lt;/p&gt;
&lt;h4&gt;查看容器（ps）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;列出当前所有正在运行的container  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;docker ps  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;列出所有的container  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;docker ps -a  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;列出最近一次启动的container &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;docker ps -l  &lt;/p&gt;
&lt;h4&gt;保存对容器的修改（commit）&lt;/h4&gt;
&lt;p&gt;当你对某一个容器做了修改之后（通过在容器中运行某一个命令），可以把对容器的修改保存下来，这样下次可以从保存后的最新状态运行该容器。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保存对容器的修改; -a, --author="" Author; -m, --message="" Commit message  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;docker commit ID new_image_name  &lt;/p&gt;
&lt;p&gt;Note：  image相当于类，Container相当于实例，不过可以动态给实例安装新软件，然后把这个container用commit命令固化成一个image。&lt;/p&gt;
&lt;h4&gt;对容器的操作（rm、stop、start、kill、logs、diff、top、cp、restart、attach）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;删除所有容器  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;docker rm &lt;code&gt;docker ps -a -q&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;删除单个容器; -f, --force=false; -l, --link=false Remove the specified link and not the underlying container; -v, --volumes=false Remove the volumes associated to the container &lt;/p&gt;
&lt;p&gt;docker rm Name/ID  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;停止、启动、杀死一个容器  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;docker stop Name/ID  &lt;/p&gt;
&lt;p&gt;docker start Name/ID  &lt;/p&gt;
&lt;p&gt;docker kill Name/ID  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从一个容器中取日志; -f, --follow=false Follow log output; -t, --timestamps=false Show timestamps  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;docker logs Name/ID  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;列出一个容器里面被改变的文件或者目录，list列表会显示出三种事件，A 增加的，D 删除的，C 被改变的  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;docker diff Name/ID  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;显示一个运行的容器里面的进程信息  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;docker top Name/ID  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从容器里面拷贝文件/目录到本地一个路径  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;docker cp Name:/container_path to_path  &lt;/p&gt;
&lt;p&gt;docker cp ID:/container_path to_path  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重启一个正在运行的容器; -t, --time=10 Number of seconds to try to stop for before killing the container, Default=10  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;docker restart Name/ID  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;附加到一个运行的容器上面; --no-stdin=false Do not attach stdin; --sig-proxy=true Proxify all received signal to the process  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;docker attach ID  &lt;/p&gt;
&lt;p&gt;Note： attach命令允许你查看或者影响一个运行的容器。你可以在同一时间attach同一个容器。你也可以从一个容器中脱离出来，是从CTRL-C。&lt;/p&gt;
&lt;h4&gt;保存和加载镜像（save、load）&lt;/h4&gt;
&lt;p&gt;当需要把一台机器上的镜像迁移到另一台机器的时候，需要保存镜像与加载镜像。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保存镜像到一个tar包; -o, --output="" Write to an file &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;docker save image_name -o file_path  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加载一个tar包格式的镜像; -i, --input="" Read from a tar archive file  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;docker load -i file_path  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;机器a  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;docker save image_name &amp;gt; /home/save.tar  &lt;/p&gt;
&lt;p&gt;使用scp将save.tar拷到机器b上，然后：  &lt;/p&gt;
&lt;p&gt;docker load &amp;lt; /home/save.tar  &lt;/p&gt;
&lt;h4&gt;登录registry server（login）&lt;/h4&gt;
&lt;p&gt;登陆registry server; -e, --email="" Email; -p, --password="" Password; -u, --username="" Username  &lt;/p&gt;
&lt;p&gt;docker login  &lt;/p&gt;
&lt;h4&gt;发布image（push）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;发布docker镜像  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;docker push new_image_name  &lt;/p&gt;
&lt;h4&gt;根据Dockerfile 构建出一个容器&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;build  &lt;/p&gt;
&lt;p&gt;--no-cache=false Do not use cache when building the image  &lt;/p&gt;
&lt;p&gt;-q, --quiet=false Suppress the verbose output generated by the containers  &lt;/p&gt;
&lt;p&gt;--rm=true Remove intermediate containers after a successful build  &lt;/p&gt;
&lt;p&gt;-t, --tag="" Repository name (and optionally a tag) to be applied to the resulting image in case of success  &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;docker build -t image_name Dockerfile_path  &lt;/p&gt;</content><category term="docker"></category></entry><entry><title>docker应用实践</title><link href="http://www.njcx.bid/posts/B3.html" rel="alternate"></link><published>2017-01-15T10:20:00+03:00</published><updated>2017-01-15T10:20:00+03:00</updated><author><name>nJcx</name></author><id>tag:www.njcx.bid,2017-01-15:/posts/B3.html</id><summary type="html">&lt;p&gt;介绍一下docker 容器应用，记录一下学习过程&lt;/p&gt;</summary><content type="html">&lt;h2&gt;安装&lt;/h2&gt;
&lt;p&gt;2017年4月测试正常,ubuntu16.04&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo apt-get -y install &lt;span class="se"&gt;\&lt;/span&gt;
  apt-transport-https &lt;span class="se"&gt;\&lt;/span&gt;
  ca-certificates &lt;span class="se"&gt;\&lt;/span&gt;
  curl

curl -fsSL https://download.docker.com/linux/ubuntu/gpg &lt;span class="p"&gt;|&lt;/span&gt; sudo apt-key add -

sudo add-apt-repository &lt;span class="se"&gt;\&lt;/span&gt;
       &lt;span class="s2"&gt;"deb [arch=amd64] https://download.docker.com/linux/ubuntu \&lt;/span&gt;
&lt;span class="s2"&gt;       &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;lsb_release -cs&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="s2"&gt; \&lt;/span&gt;
&lt;span class="s2"&gt;       stable"&lt;/span&gt;

sudo apt-get update
sudo apt-get -y install docker-ce
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Docker的三个基本概念&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;镜像&lt;/li&gt;
&lt;li&gt;容器&lt;/li&gt;
&lt;li&gt;仓库&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;容器是镜像的一次运行,修改需要提交,仓库是放镜像的地方,hub是放仓库的地方&lt;/p&gt;
&lt;h2&gt;Docker的使用&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.njcxs.cc/posts/B4.html"&gt;docker 常用命令记录&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt;Docker几乎就没有什么虚拟化的东西，并且直接复用了Host主机的OS，在Docker Engine层面实现了调度和隔离重量一下子就降低了好几个档次.Docker的容器利用了LXC，管理利用了namespaces 来做权限的控制和隔离,cgroups来进行资源的配置,并且还通过aufs来进一步提高文件系统的资源利用率。其中的 aufs 是个很有意思的东西，是 UnionFS的一种.他的思想和 git 有些类似，可以把对文件系统的改动当成一次 commit 一层层的叠加。这样的话多个容器之间就可以共享他们的文件系统层次，每个容器下面都是共享的文件系统层次，上面再是各自对文件系统改动的层次，这样的话极大的节省了对存储的需求，并且也能加速容器的启动。&lt;/p&gt;
&lt;p&gt;这可以在单一Linux实体下运作，避免引导一个虚拟机造成的额外负担。Linux核心对名字空间的支持完全隔离了工作环境中应用程序的视野，包括进程树、网络、用户ID与挂载文件系统，而核心的cgroup提供资源隔离，包括CPU、内存、block I/O与网络。从0.9版本起，Dockers在使用抽象虚拟是经由libvirt的 LXC与systemd - nspawn提供界面的基础上，开始包括libcontainer库做为以自己的方式开始直接使用由Linux核心提供的虚拟化的设施，&lt;/p&gt;
&lt;p&gt;那么什么是cgroups呢？cgroups，其名称源自控制组群（control groups）的简写，是Linux内核的一个功能，用来限制，控制与分离一个进程组群的资源（如CPU、内存、磁盘输入输出等）。最早的名称为进程容器（process containers）。在2007年时，因为在Linux内核中，容器（container）这个名词有许多不同的意义，为避免混乱，被重命名为cgroup，并且被合并到2.6.24版的内核中去。&lt;/p&gt;
&lt;p&gt;LXC又是什么呢？LXC，其名称来自Linux软件容器（Linux Containers）的缩写，一种操作系统层虚拟化（Operating system–level virtualization）技术，为Linux内核容器功能的一个用户空间接口。它将应用软件系统打包成一个软件容器（Container），内含应用软件本身的代码，以及所需要的操作系统核心和库。通过统一的名字空间和共用API来分配不同软件容器的可用硬件资源，创造出应用程序的独立沙箱运行环境，使得Linux用户可以容易的创建和管理系统或应用容器。(感觉好像没有讲一样）&lt;/p&gt;
&lt;h2&gt;一些应用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;环境打包&lt;/li&gt;
&lt;li&gt;应用隔离&lt;/li&gt;
&lt;li&gt;基础镜像&lt;/li&gt;
&lt;/ul&gt;</content><category term="docker"></category></entry><entry><title>Linux 运维常用命令总结</title><link href="http://www.njcx.bid/posts/B1.html" rel="alternate"></link><published>2017-01-13T10:20:00+03:00</published><updated>2017-01-13T10:20:00+03:00</updated><author><name>nJcx</name></author><id>tag:www.njcx.bid,2017-01-13:/posts/B1.html</id><summary type="html">&lt;p&gt;Linux 运维常用命令总结&lt;/p&gt;</summary><content type="html">&lt;h2&gt;Linux 运维常用命令总结&lt;/h2&gt;
&lt;p&gt;很多都是从网上收集的和自己总结的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;网卡绑定多IP&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ifconfig eth0:1 192.168.1.99 netmask 255.255.255.0&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置DNS、网关&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;echo "nameserver 202.16.53.68" &amp;gt;&amp;gt; /etc/resolv.conf
route add default gw 192.168.1.1&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查看系统版本&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;lsb_release -a&lt;/p&gt;
&lt;p&gt;cat /etc/issue&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查看系统信息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;uname -a&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查看物理CPU个数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;cat /proc/cpuinfo| grep "physical id"| sort| uniq| wc -l&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查看当前登录用户:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;root@debian:/home/njcx# who&lt;/p&gt;
&lt;p&gt;njcx     :0           2017-05-21 08:11 (:0)&lt;/p&gt;
&lt;p&gt;njcx     pts/0        2017-05-21 18:24 (:0.0)&lt;/p&gt;
&lt;p&gt;第一列是用户名,
第二列是连接的终端,tty表示显示器,pts表示远程连接,
第三列是登陆时间,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查看登录用户行为:
root@debian:/home/njcx# w&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;18:32:52 up 10:21,  2 users,  load average: 0.74, 0.35, 0.23&lt;/p&gt;
&lt;p&gt;USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT&lt;/p&gt;
&lt;p&gt;njcx     :0       :0               08:11   ?xdm?  38:14   0.31s x-session-manag&lt;/p&gt;
&lt;p&gt;njcx     pts/0    :0.0             18:24    1.00s  0.09s  3.44s mate-terminal&lt;/p&gt;
&lt;p&gt;users 表示当前系统登陆用户总数为2。&lt;/p&gt;
&lt;p&gt;LOAD AVERAGE 与后面的数字一起表示系统在过去1，5，10分钟内的负载程度，数值越小，系统负载越轻。&lt;/p&gt;
&lt;p&gt;从第二行开始构成一个表格，共有8个栏目，分别显示各个用户正在做的事情及该用户所占用的系统资料。&lt;/p&gt;
&lt;p&gt;USER：显示登陆用户帐号名。用户重复登陆，该帐号也会重复出现。&lt;/p&gt;
&lt;p&gt;TTY：用户登陆所用的终端。&lt;/p&gt;
&lt;p&gt;FROM：显示用户在何处登陆系统。&lt;/p&gt;
&lt;p&gt;LOGIN@：是LOGIN AT的意思，表示登陆进入系统的时间。&lt;/p&gt;
&lt;p&gt;IDLE：用户空闲时间，从用户上一次任务结束后，开始记时。&lt;/p&gt;
&lt;p&gt;JCPU：一终端代号来区分，表示在某段时间内，所有与该终端相关的进程任务所耗费的CPU时间。&lt;/p&gt;
&lt;p&gt;PCPU：指WHAT域的任务执行后耗费的CPU时间。&lt;/p&gt;
&lt;p&gt;WHAT：表示当前执行的任务&lt;/p&gt;
&lt;p&gt;当登陆系统用户很多的时候，可以在W后面加上某个用户名，则会查看该用户执行任务的情况&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;强制踢出登陆用户&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;pkill -KILL -t pts/1&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tar命令&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;tar.gz&lt;/p&gt;
&lt;p&gt;压缩：tar -zcvf archive_name.tar.gz directory_to_compress&lt;/p&gt;
&lt;p&gt;解压缩： tar -zxvf archive_name.tar.gz&lt;/p&gt;
&lt;p&gt;tar.bz2&lt;/p&gt;
&lt;p&gt;压缩  ： tar -jcvf test.tar.bz2 test&lt;/p&gt;
&lt;p&gt;解压： tar -jxvf test.tar.bz2 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将本地80端口的请求转发到8080端口，当前主机外网IP为202.96.85.46&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A PREROUTING -d 202.96.85.46 -p tcp -m tcp --dport 80 -j DNAT --to-destination 192.168.9.10:8080&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在11月份内，每天的早上6点到12点中，每隔2小时执行一次/usr/bin/httpd.sh&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;crontab -e&lt;/p&gt;
&lt;p&gt;0 6-12/2 * 11 * /usr/bin/httpd.sh&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查看占用端口8080的进程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;netstat -tnlp | grep 8080&lt;/p&gt;
&lt;p&gt;lsof -i:8080&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在Shell环境下,如何查看远程Linux系统运行了多少时间?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ssh user@被监控主机ip "uptime"&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查看CPU使用情况的命令&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;""每5秒刷新一次，最右侧有CPU的占用率的数据&lt;/p&gt;
&lt;p&gt;vmstat 5&lt;/p&gt;
&lt;p&gt;""top 然后按Shift+P，按照进程处理器占用率排序
top&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查看磁盘空间占用情况&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;df -hl&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查看内存使用情况的命令&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;""用free命令查看内存使用情况&lt;/p&gt;
&lt;p&gt;free -m&lt;/p&gt;
&lt;p&gt;""top 然后按Shift+M, 按照进程内存占用率排序&lt;/p&gt;
&lt;p&gt;top&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;修复文件系统&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;fsck –yt ext3 /&lt;/p&gt;
&lt;p&gt;-t 指定文件系统&lt;/p&gt;
&lt;p&gt;-y 对发现的问题自动回答yes&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;read 命令5秒后自动退出&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;read -t 5&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;vi编辑器(涉及到修改，添加，查找)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;插入(insert)模式&lt;/p&gt;
&lt;p&gt;i　　　　光标前插入&lt;/p&gt;
&lt;p&gt;I　　　　光标行首插入&lt;/p&gt;
&lt;p&gt;a　　　　光标后插入&lt;/p&gt;
&lt;p&gt;A　　　　光标行尾插入&lt;/p&gt;
&lt;p&gt;o　　　　光标所在行下插入一行，行首插入&lt;/p&gt;
&lt;p&gt;O　　　　光标所在行上插入一行，行首插入&lt;/p&gt;
&lt;p&gt;G　　　　移至最后一行行首&lt;/p&gt;
&lt;p&gt;nG　　　　移至第n行行首&lt;/p&gt;
&lt;p&gt;n+　　　　下移n行，行首&lt;/p&gt;
&lt;p&gt;n-　　　　上移n行，行首&lt;/p&gt;
&lt;p&gt;:/str/　　　　　　　　　　从当前往右移动到有str的地方&lt;/p&gt;
&lt;p&gt;:?str?　　　　　　　　　　从当前往左移动到有str的地方&lt;/p&gt;
&lt;p&gt;:s/str1/str2/　　　　　　将找到的第一个str1替换为str2　
　
:s/str2/str2/g　　　　　　将当前行找到的所有str1替换为str2&lt;/p&gt;
&lt;p&gt;:n1,n2s/str1/str2/g　　　　将从n1行至n2行找到的所有的str1替换为str2&lt;/p&gt;
&lt;p&gt;:1,.s/str1/str2/g　　　　　　将从第1行至当前行的所有str1替换为str2&lt;/p&gt;
&lt;p&gt;:.,$s/str1/str2/g　　　　　　将从当前行至最后一行的所有str1替换为str2&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;linux服务器之间相互复制文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;copy 本地文件1.sh到远程192.168.9.10服务器的/data/目录下&lt;/p&gt;
&lt;p&gt;scp /etc/1.sh king@192.168.9.10:/data/&lt;/p&gt;
&lt;p&gt;copy远程192.168.9.10服务器/data/2.sh文件到本地/data/目录&lt;/p&gt;
&lt;p&gt;scp king@192.168.9.10:/data/2.sh /data/&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何查看目标主机192.168.0.1开放那些端口&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;nmap -PS 192.168.0.1&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何查看当前系统使用了那些库文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ldconfig -v&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何查看网卡的驱动版本&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ethtool -i eth0&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用tcpdump来监视主机192.168.0.1的tcp的80端口&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;tcpdump tcp port 80 host 192.168.0.1                                               &lt;/p&gt;</content><category term="Linux"></category></entry><entry><title>Nginx 作为负载均衡服务器应用实践</title><link href="http://www.njcx.bid/posts/A7.html" rel="alternate"></link><published>2016-08-07T10:20:00+03:00</published><updated>2016-08-07T10:20:00+03:00</updated><author><name>nJcx</name></author><id>tag:www.njcx.bid,2016-08-07:/posts/A7.html</id><summary type="html">&lt;p&gt;介绍一下Nginx 作为Web负载均衡服务器应用，记录一下学习过程&lt;/p&gt;</summary><content type="html">&lt;h4&gt;nginx负载均衡配置&lt;/h4&gt;
&lt;p&gt;准备三台虚拟机来做这个实验：&lt;/p&gt;
&lt;p&gt;192.168.121.87        web服务器
192.168.121.62        web服务器
192.168.121.134        负载均衡服务器&lt;/p&gt;
&lt;p&gt;首先把负载均衡服务器安装nginx&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;yum install nginx  
chkconfig nginx on  
service nginx start
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;向web服务器中放入测试文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;html&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;    
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;head&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;    
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;title&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;Welcome to test!&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;title&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;    
&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;head&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;    
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;body&lt;/span&gt; &lt;span class="na"&gt;bgcolor&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"white"&lt;/span&gt; &lt;span class="na"&gt;text&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"black"&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;    
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;center&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;h1&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;A&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;h1&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;center&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;    
&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;body&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;    
&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;html&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置负载均衡服务器：
vi /etc/nginx/nginx.conf
内容如下：&lt;/p&gt;
&lt;p&gt;user  nginx;&lt;br/&gt;
worker_processes  1;  &lt;/p&gt;
&lt;p&gt;error_log  /var/log/nginx/error.log warn;&lt;br/&gt;
pid        /var/run/nginx.pid;  &lt;/p&gt;
&lt;p&gt;events {&lt;br/&gt;
    worker_connections  1024;&lt;br/&gt;
}  &lt;/p&gt;
&lt;p&gt;http {&lt;br/&gt;
    include       /etc/nginx/mime.types;&lt;br/&gt;
    default_type  application/octet-stream;  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;log_format&lt;/span&gt;  &lt;span class="nt"&gt;main&lt;/span&gt;  &lt;span class="s1"&gt;'$remote_addr - $remote_user &lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;$time_local&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="s1"&gt; "$request" '&lt;/span&gt;  
                  &lt;span class="s1"&gt;'$status $body_bytes_sent "$http_referer" '&lt;/span&gt;  
                  &lt;span class="s1"&gt;'"$http_user_agent" "$http_x_forwarded_for"'&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

&lt;span class="nt"&gt;access_log&lt;/span&gt;  &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nt"&gt;var&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nt"&gt;log&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nt"&gt;nginx&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nt"&gt;access&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;log&lt;/span&gt;  &lt;span class="nt"&gt;main&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

&lt;span class="nt"&gt;sendfile&lt;/span&gt;        &lt;span class="nt"&gt;on&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;#&lt;/span&gt;&lt;span class="nn"&gt;tcp_nopush&lt;/span&gt;     &lt;span class="nt"&gt;on&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

&lt;span class="nt"&gt;keepalive_timeout&lt;/span&gt;  &lt;span class="nt"&gt;65&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

&lt;span class="p"&gt;#&lt;/span&gt;&lt;span class="nn"&gt;gzip&lt;/span&gt;  &lt;span class="nt"&gt;on&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;  
&lt;span class="nt"&gt;upstream&lt;/span&gt; &lt;span class="nt"&gt;test&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;miaohr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;com&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  
&lt;span class="err"&gt;server&lt;/span&gt; &lt;span class="err"&gt;192.168.232.132:80&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="err"&gt;server&lt;/span&gt; &lt;span class="err"&gt;192.168.232.133:80&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="nt"&gt;server&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;     
    &lt;span class="err"&gt;listen&lt;/span&gt;       &lt;span class="err"&gt;80&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     
    &lt;span class="err"&gt;server_name&lt;/span&gt;  &lt;span class="err"&gt;test.miaohr.com&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     
    &lt;span class="err"&gt;charset&lt;/span&gt; &lt;span class="err"&gt;utf-8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     
    &lt;span class="err"&gt;location&lt;/span&gt; &lt;span class="err"&gt;/&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;     
        &lt;span class="err"&gt;root&lt;/span&gt;   &lt;span class="err"&gt;html&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     
        &lt;span class="err"&gt;index&lt;/span&gt;  &lt;span class="err"&gt;index.html&lt;/span&gt; &lt;span class="err"&gt;index.htm&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     
        &lt;span class="err"&gt;proxy_pass&lt;/span&gt;        &lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;miaohr&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     
        &lt;span class="err"&gt;proxy_set_header&lt;/span&gt;  &lt;span class="err"&gt;X-Real-IP&lt;/span&gt;  &lt;span class="err"&gt;$remote_addr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     
        &lt;span class="err"&gt;client_max_body_size&lt;/span&gt;  &lt;span class="err"&gt;100m&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="p"&gt;}&lt;/span&gt;


    &lt;span class="nt"&gt;location&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt; &lt;span class="o"&gt;^/(&lt;/span&gt;&lt;span class="nt"&gt;WEB-INF&lt;/span&gt;&lt;span class="o"&gt;)/&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;      
    &lt;span class="err"&gt;deny&lt;/span&gt; &lt;span class="err"&gt;all&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;      
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="nt"&gt;error_page&lt;/span&gt;   &lt;span class="nt"&gt;500&lt;/span&gt; &lt;span class="nt"&gt;502&lt;/span&gt; &lt;span class="nt"&gt;503&lt;/span&gt; &lt;span class="nt"&gt;504&lt;/span&gt;  &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nt"&gt;50x&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;html&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;     
    &lt;span class="nt"&gt;location&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nt"&gt;50x&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;html&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;     
        &lt;span class="err"&gt;root&lt;/span&gt;   &lt;span class="err"&gt;/var/www/html/&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     
    &lt;span class="p"&gt;}&lt;/span&gt;     
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;}  &lt;/p&gt;
&lt;p&gt;下面浏览器打开:192.168.232.134，如果132、133交替显示则表明试验成功。&lt;/p&gt;
&lt;p&gt;拓展：&lt;/p&gt;
&lt;p&gt;1、轮询（默认）
每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。&lt;/p&gt;
&lt;p&gt;2、weight
指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。
例如：
upstream bakend {
server 192.168.159.10 weight=10;
server 192.168.159.11 weight=10;
}&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ip_hash&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。
例如：
upstream resinserver{
ip_hash;
server 192.168.159.10:8080;
server 192.168.159.11:8080;
}&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;fair（第三方）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;按后端服务器的响应时间来分配请求，响应时间短的优先分配。
upstream resinserver{
server server1;
server server2;
fair;
}&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;url_hash（第三方）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。
例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法&lt;/p&gt;
&lt;p&gt;upstream resinserver{
server squid1:3128;
server squid2:3128;
hash $request_uri;
hash_method crc32;
}&lt;/p&gt;
&lt;p&gt;tips:&lt;/p&gt;
&lt;p&gt;upstream resinserver{#定义负载均衡设备的Ip及设备状态
ip_hash;
server 127.0.0.1:8000 down;
server 127.0.0.1:8080 weight=2;
server 127.0.0.1:6801;
server 127.0.0.1:6802 backup;
}&lt;/p&gt;
&lt;p&gt;在需要使用负载均衡的server中增加
proxy_pass http://resinserver/;&lt;/p&gt;
&lt;p&gt;每个设备的状态设置为:
1.down 表示单前的server暂时不参与负载
2.weight 默认为1.weight越大，负载的权重就越大。
3.max_fails ：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream 模块定义的错误
4.fail_timeout:max_fails次失败后，暂停的时间。
5.backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。&lt;/p&gt;
&lt;p&gt;nginx支持同时设置多组的负载均衡，用来给不用的server来使用。&lt;/p&gt;
&lt;p&gt;client_body_in_file_only 设置为On 可以讲client post过来的数据记录到文件中用来做debug
client_body_temp_path 设置记录文件的目录 可以设置最多3层目录
location 对URL进行匹配.可以进行重定向或者进行新的代理 负载均衡&lt;/p&gt;</content><category term="集群，HA"></category></entry><entry><title>MySQL主从复制解决方案实践</title><link href="http://www.njcx.bid/posts/A2.html" rel="alternate"></link><published>2016-01-02T10:20:00+03:00</published><updated>2016-01-02T10:20:00+03:00</updated><author><name>nJcx</name></author><id>tag:www.njcx.bid,2016-01-02:/posts/A2.html</id><summary type="html">&lt;p&gt;介绍一下linux下mysql主从复制搭建过程，记录一下学习过程&lt;/p&gt;</summary><content type="html">&lt;h2&gt;测试环境&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;kvm&lt;/li&gt;
&lt;li&gt;ubuntu16.04 server x2&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="mysql1" class="img-fluid" src="../images/mysql1.png"/&gt;&lt;/p&gt;
&lt;h2&gt;安装mysql&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; apt-get install -y mysql-server
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;配置&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mysql&amp;gt;create user repl&lt;span class="p"&gt;;&lt;/span&gt; //创建新用户
//repl用户必须具有REPLICATION SLAVE权限，除此之外没有必要添加不必要的权限，密码为mysql。说明一下192.168.0.%，这个配置是指明repl用户所在服务器，这里%是通配符，表示192.168.0.0-192.168.0.255的Server都可以以repl用户登陆主服务器。当然你也可以指定固定Ip。
mysql&amp;gt; GRANT REPLICATION SLAVE ON *.* TO &lt;span class="s1"&gt;'repl'&lt;/span&gt;@&lt;span class="s1"&gt;'192.168.122.%'&lt;/span&gt; IDENTIFIED BY &lt;span class="s1"&gt;'123456'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</content><category term="MySQL"></category></entry><entry><title>centos6.8 下lvs+keepalived高并发实践</title><link href="http://www.njcx.bid/posts/A1.html" rel="alternate"></link><published>2016-01-01T10:20:00+03:00</published><updated>2016-01-01T10:20:00+03:00</updated><author><name>nJcx</name></author><id>tag:www.njcx.bid,2016-01-01:/posts/A1.html</id><summary type="html">&lt;p&gt;介绍一下linux下lvs+keepalived　搭建过程，记录一下学习过程&lt;/p&gt;</summary><content type="html">&lt;h2&gt;安装&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;yum install -y keepalived &lt;/li&gt;
&lt;li&gt;yum install -y ipvsadm&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;配置&lt;/h2&gt;
&lt;p&gt;MASTER&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vrrp_instance VI_1 &lt;span class="o"&gt;{&lt;/span&gt;
            state MASTER            &lt;span class="c1"&gt;# 状态实际MASTER&lt;/span&gt;
            interface eth0            &lt;span class="c1"&gt;# 监听网卡切换&lt;/span&gt;
            virtual_router_id &lt;span class="m"&gt;51&lt;/span&gt;
            priority &lt;span class="m"&gt;100&lt;/span&gt;                &lt;span class="c1"&gt;# 优先级（越大优先级越高）&lt;/span&gt;
            advert_int &lt;span class="m"&gt;1&lt;/span&gt;
            authentication &lt;span class="o"&gt;{&lt;/span&gt;
                auth_type PASS
                auth_pass &lt;span class="m"&gt;1111&lt;/span&gt;
            &lt;span class="o"&gt;}&lt;/span&gt;
            virtual_ipaddress &lt;span class="o"&gt;{&lt;/span&gt;        &lt;span class="c1"&gt;# 虚拟IP地址列表，即VIP&lt;/span&gt;
                &lt;span class="m"&gt;172&lt;/span&gt;.28.14.227
                &lt;span class="m"&gt;172&lt;/span&gt;.28.14.228
                &lt;span class="m"&gt;172&lt;/span&gt;.28.14.229
            &lt;span class="o"&gt;}&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
        virtual_server &lt;span class="m"&gt;172&lt;/span&gt;.28.14.227 &lt;span class="m"&gt;8080&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
            delay_loop &lt;span class="m"&gt;6&lt;/span&gt;
            lb_algo wlc
            lb_kind DR                    &lt;span class="c1"&gt;# DR模式&lt;/span&gt;
            persistence_timeout &lt;span class="m"&gt;50&lt;/span&gt;
            protocol TCP
            real_server &lt;span class="m"&gt;172&lt;/span&gt;.28.19.100 &lt;span class="m"&gt;8080&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
                weight &lt;span class="m"&gt;1&lt;/span&gt;                  &lt;span class="c1"&gt;# 权重（权重越高处理的请求越多）&lt;/span&gt;
                TCP_CHECK &lt;span class="o"&gt;{&lt;/span&gt;
                    connect_timeout &lt;span class="m"&gt;3&lt;/span&gt;
                    nb_get_retry &lt;span class="m"&gt;3&lt;/span&gt;
                    delay_before_retry &lt;span class="m"&gt;3&lt;/span&gt;
                    connect_port &lt;span class="m"&gt;8080&lt;/span&gt;
                &lt;span class="o"&gt;}&lt;/span&gt;
            &lt;span class="o"&gt;}&lt;/span&gt;
            real_server &lt;span class="m"&gt;172&lt;/span&gt;.28.19.101 &lt;span class="m"&gt;8080&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
                weight &lt;span class="m"&gt;1&lt;/span&gt;                  &lt;span class="c1"&gt;# 权重（权重越高处理的请求越多）&lt;/span&gt;
                TCP_CHECK &lt;span class="o"&gt;{&lt;/span&gt;
                    connect_timeout &lt;span class="m"&gt;3&lt;/span&gt;
                    nb_get_retry &lt;span class="m"&gt;3&lt;/span&gt;
                    delay_before_retry &lt;span class="m"&gt;3&lt;/span&gt;
                    connect_port &lt;span class="m"&gt;8080&lt;/span&gt;
                &lt;span class="o"&gt;}&lt;/span&gt;
            &lt;span class="o"&gt;}&lt;/span&gt;
            real_server &lt;span class="m"&gt;172&lt;/span&gt;.28.19.102 &lt;span class="m"&gt;8080&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
                weight &lt;span class="m"&gt;1&lt;/span&gt;                  &lt;span class="c1"&gt;# 权重（权重越高处理的请求越多）&lt;/span&gt;
                TCP_CHECK &lt;span class="o"&gt;{&lt;/span&gt;
                    connect_timeout &lt;span class="m"&gt;3&lt;/span&gt;
                    nb_get_retry &lt;span class="m"&gt;3&lt;/span&gt;
                    delay_before_retry &lt;span class="m"&gt;3&lt;/span&gt;
                    connect_port &lt;span class="m"&gt;8080&lt;/span&gt;
                &lt;span class="o"&gt;}&lt;/span&gt;
            &lt;span class="o"&gt;}&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
        virtual_server &lt;span class="m"&gt;172&lt;/span&gt;.28.14.228 &lt;span class="m"&gt;25&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
            delay_loop &lt;span class="m"&gt;6&lt;/span&gt;
            lb_algo wlc
            lb_kind DR                    &lt;span class="c1"&gt;# DR模式&lt;/span&gt;
            persistence_timeout &lt;span class="m"&gt;50&lt;/span&gt;
            protocol TCP
            real_server &lt;span class="m"&gt;172&lt;/span&gt;.28.19.103 &lt;span class="m"&gt;25&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
                weight &lt;span class="m"&gt;1&lt;/span&gt;                  &lt;span class="c1"&gt;# 权重（权重越高处理的请求越多）&lt;/span&gt;
                TCP_CHECK &lt;span class="o"&gt;{&lt;/span&gt;
                    connect_timeout &lt;span class="m"&gt;3&lt;/span&gt;
                    nb_get_retry &lt;span class="m"&gt;3&lt;/span&gt;
                    delay_before_retry &lt;span class="m"&gt;3&lt;/span&gt;
                    connect_port &lt;span class="m"&gt;25&lt;/span&gt;
                &lt;span class="o"&gt;}&lt;/span&gt;
            &lt;span class="o"&gt;}&lt;/span&gt;
            real_server &lt;span class="m"&gt;172&lt;/span&gt;.28.19.104 &lt;span class="m"&gt;25&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
                weight &lt;span class="m"&gt;1&lt;/span&gt;                  &lt;span class="c1"&gt;# 权重（权重越高处理的请求越多）&lt;/span&gt;
                TCP_CHECK &lt;span class="o"&gt;{&lt;/span&gt;
                    connect_timeout &lt;span class="m"&gt;3&lt;/span&gt;
                    nb_get_retry &lt;span class="m"&gt;3&lt;/span&gt;
                    delay_before_retry &lt;span class="m"&gt;3&lt;/span&gt;
                    connect_port &lt;span class="m"&gt;25&lt;/span&gt;
                &lt;span class="o"&gt;}&lt;/span&gt;
            &lt;span class="o"&gt;}&lt;/span&gt;
            real_server &lt;span class="m"&gt;172&lt;/span&gt;.28.19.105 &lt;span class="m"&gt;25&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
                weight &lt;span class="m"&gt;1&lt;/span&gt;                  &lt;span class="c1"&gt;# 权重（权重越高处理的请求越多）&lt;/span&gt;
                TCP_CHECK &lt;span class="o"&gt;{&lt;/span&gt;
                    connect_timeout &lt;span class="m"&gt;3&lt;/span&gt;
                    nb_get_retry &lt;span class="m"&gt;3&lt;/span&gt;
                    delay_before_retry &lt;span class="m"&gt;3&lt;/span&gt;
                    connect_port &lt;span class="m"&gt;25&lt;/span&gt;
                &lt;span class="o"&gt;}&lt;/span&gt;
            &lt;span class="o"&gt;}&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
        virtual_server &lt;span class="m"&gt;172&lt;/span&gt;.28.14.229 &lt;span class="m"&gt;21&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
            delay_loop &lt;span class="m"&gt;6&lt;/span&gt;
            lb_algo wlc
            lb_kind DR                    &lt;span class="c1"&gt;# DR模式&lt;/span&gt;
            persistence_timeout &lt;span class="m"&gt;50&lt;/span&gt;
            protocol TCP
            real_server &lt;span class="m"&gt;172&lt;/span&gt;.28.19.106 &lt;span class="m"&gt;21&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
                weight &lt;span class="m"&gt;1&lt;/span&gt;                  &lt;span class="c1"&gt;# 权重（权重越高处理的请求越多）&lt;/span&gt;
                TCP_CHECK &lt;span class="o"&gt;{&lt;/span&gt;
                    connect_timeout &lt;span class="m"&gt;3&lt;/span&gt;
                    nb_get_retry &lt;span class="m"&gt;3&lt;/span&gt;
                    delay_before_retry &lt;span class="m"&gt;3&lt;/span&gt;
                    connect_port &lt;span class="m"&gt;21&lt;/span&gt;
                &lt;span class="o"&gt;}&lt;/span&gt;
            &lt;span class="o"&gt;}&lt;/span&gt;
            real_server &lt;span class="m"&gt;172&lt;/span&gt;.28.19.107 &lt;span class="m"&gt;21&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
                weight &lt;span class="m"&gt;1&lt;/span&gt;                  &lt;span class="c1"&gt;# 权重（权重越高处理的请求越多）&lt;/span&gt;
                TCP_CHECK &lt;span class="o"&gt;{&lt;/span&gt;
                    connect_timeout &lt;span class="m"&gt;3&lt;/span&gt;
                    nb_get_retry &lt;span class="m"&gt;3&lt;/span&gt;
                    delay_before_retry &lt;span class="m"&gt;3&lt;/span&gt;
                    connect_port &lt;span class="m"&gt;21&lt;/span&gt;
                &lt;span class="o"&gt;}&lt;/span&gt;
            &lt;span class="o"&gt;}&lt;/span&gt;
            real_server &lt;span class="m"&gt;172&lt;/span&gt;.28.19.108 &lt;span class="m"&gt;21&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
                weight &lt;span class="m"&gt;1&lt;/span&gt;                  &lt;span class="c1"&gt;# 权重（权重越高处理的请求越多）&lt;/span&gt;
                TCP_CHECK &lt;span class="o"&gt;{&lt;/span&gt;
                    connect_timeout &lt;span class="m"&gt;3&lt;/span&gt;
                    nb_get_retry &lt;span class="m"&gt;3&lt;/span&gt;
                    delay_before_retry &lt;span class="m"&gt;3&lt;/span&gt;
                    connect_port &lt;span class="m"&gt;21&lt;/span&gt;
                &lt;span class="o"&gt;}&lt;/span&gt;
            &lt;span class="o"&gt;}&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;BACKUP&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        vrrp_instance VI_1 &lt;span class="o"&gt;{&lt;/span&gt;
            state BACKP            &lt;span class="c1"&gt;# 状态实际BACKUP&lt;/span&gt;
            ...
            priority &lt;span class="m"&gt;99&lt;/span&gt;                &lt;span class="c1"&gt;# 优先级99（比MASTER优先级100低）&lt;/span&gt;
            ...
        &lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;realserver&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; &lt;span class="c1"&gt;#!/bin/bash&lt;/span&gt;
        &lt;span class="nv"&gt;VIP&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;172&lt;/span&gt;.28.14.227
        . /etc/rc.d/init.d/functions
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$1&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; in
        start&lt;span class="o"&gt;)&lt;/span&gt;
            &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt; &amp;gt; /proc/sys/net/ipv4/conf/lo/arp_ignore
            &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt; &amp;gt; /proc/sys/net/ipv4/conf/lo/arp_announce
            &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt; &amp;gt; /proc/sys/net/ipv4/conf/all/arp_ignore
            &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt; &amp;gt; /proc/sys/net/ipv4/conf/all/arp_announce
            ifconfig lo:0 &lt;span class="nv"&gt;$VIP&lt;/span&gt; broadcast &lt;span class="nv"&gt;$VIP&lt;/span&gt; netmask &lt;span class="m"&gt;255&lt;/span&gt;.255.255.255 up
            /sbin/route add -host &lt;span class="nv"&gt;$VIP&lt;/span&gt; dev lo:0
            sysctl -p &amp;gt; /dev/null &lt;span class="m"&gt;2&lt;/span&gt;&amp;gt;&lt;span class="p"&gt;&amp;amp;&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;
            &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"realserver start OK"&lt;/span&gt;
            &lt;span class="p"&gt;;;&lt;/span&gt;
        stop&lt;span class="o"&gt;)&lt;/span&gt;
            &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt; &amp;gt; /proc/sys/net/ipv4/conf/lo/arp_ignore
            &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt; &amp;gt; /proc/sys/net/ipv4/conf/lo/arp_announce
            &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt; &amp;gt; /proc/sys/net/ipv4/conf/all/arp_ignore
            &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt; &amp;gt; /proc/sys/net/ipv4/conf/all/arp_announce
            ifconfig lo:0 down
            /sbin/route del &lt;span class="nv"&gt;$VIP&lt;/span&gt; &amp;gt; /dev/null &lt;span class="m"&gt;2&lt;/span&gt;&amp;gt;&lt;span class="p"&gt;&amp;amp;&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;
            &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"realserver stoped"&lt;/span&gt;
            &lt;span class="p"&gt;;;&lt;/span&gt;
        *&lt;span class="o"&gt;)&lt;/span&gt;
            &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"Usage:&lt;/span&gt;&lt;span class="nv"&gt;$0&lt;/span&gt;&lt;span class="s2"&gt; {start|stop}"&lt;/span&gt;
            &lt;span class="nb"&gt;exit&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;
        &lt;span class="k"&gt;esac&lt;/span&gt;
        &lt;span class="nb"&gt;exit&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;测试&lt;/h2&gt;
&lt;p&gt;把两个web server 页面设置不同实测.&lt;/p&gt;</content><category term="集群，HA"></category></entry></feed>